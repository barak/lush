#? *** Events and Timers

#? ** Event Queue
.SEE Event Lists.
.SEE Ogre.

The Lush interpreter provides a centralized machanism for queuing and
dispatching events.  Events are represented by arbitrary non-empty lists.  The
event lists discussed in section "Event Lists" are merely the events generated
by the window system.

Function <sendevent> is the simplest way to generate an event.  Besides the
event itself, function <sendevent> requires an "event handler", that is to say
an arbitrary non null lisp object.  The event handler can be merely used as a
key to identify the target of the event.  Yet it is strongly suggested that
the event handler should be a lisp object that recognizes method <handle>.

Besides function <sendevent>, events can be generated by defining a timer
using <create-timer>, or by associating an event handler with a graphic window
using function <set-event-handler>.

Although events can be polled manually using functions <testevent>,
<checkevent>, and <waitevent>, it is often more practical to let Lush dispatch
the events automatically.  Lush silently polls the event queue whenever it is
waiting for input on the console.  All available events are dispatched by
calling the method <handle> of their event handler with the event itself as a
single argument. These automatic call allow the implementation of asynchronous
graphic interfaces, like those implemented by the Ogre library.


#? (set-event-handler <w> <h>)
.SEE Ogre.
Associates the event handler <h> with window <w>.  The new event handler for
window <w> replaces the old one.  Providing the empty list as argument <h>
simply removes the previous event handler without defining a new one.
Once an event handler has been attached to a window, graphics events occuring
on that window, like mouse or keyboard interaction, are posted on the lush
event queue and dispatched as usual.

#? (create-timer <handler> <delay> [<interval>])
.SEE Timers 
.SEE (new Timer [<delay> [<interval>]] [<callback>])

Creates a timer that generates an event <(timer <timerid>)> for handler
<handler> every <interval> milliseconds after an initial delay of <delay>
milliseconds.  Specifying an interval of zero milliseconds creates a one shot
timer that fires only once after <delay> milliseconds.  This function returns
a timer identifier that can be used with function <kill-timer>.
Section "Timers" describe a more convenient way to define a timer.

#? (create-timer-absolute <handler> <date>)
Creates a timer that generates an event <(timer <timerid>)> for handler
<handler> at the specified date. Dates are real numbers representing
a number of seconds spent since a system dependent date. 

#? (kill-timer <timerid>)
.SEE (create-timer <handler> <delay> [<interval>])
Destroys the timer <timerid>.

#? (sendevent <handler> <event>)
Posts and event <event> with event handler <handler>.  Argument <event> must
be a non empty list.  Argument <handler> must be a non null object.  It is
customary (but not mandatory) to make sure that the event handler recognizes
method <handle> for processing automatically displatched events.

#? (sendevent <x> <y>)
This obsolete form of sendevent takes two integer arguments
and posts event <(sendevent <x> <y>)> to the event handler associated
with the current window.

#? (testevent [<h>])
Function <testevent> returns the first event available for handler <h>
without removing the event from the queue.  When argument <h> is omitted,
function <testevent> implicitely uses the event handler associated
with the current window. 

Function <testevent> works differently when argument <h> is the empty list.
It returns the event handler associated with the first pending event, 
or the empty list if no events are pending.

When no suitable event is pending, function <testevent> returns
the empty list without waiting.

#? (checkevent [<h>])
Function <checkevent> returns the first event available for handler <h>
and removes it from the queue.  When argument <h> is omitted,
function <checkevent> implicitely uses the event handler associated
with the current window.

Function <checkevent> works differently when argument <h> is the empty list.
It returns the event handler associated with the first pending event,
without modifying the queue.

When no suitable event is pending, function <checkevent> returns
the empty list without waiting.

#? (waitevent)
Function <waitevent> first tests the event queue and 
returns the event handler associated with the first pending event. 
Otherwise function <waitevent> waits until an event occurs
and returns the associated event handler.

#? (process-pending-events)
Function <process-pending-events> dispatches all pending events.  While there
are pending events, function <process-pending-events> removes the first event
from the queue, checks whether the associated event handler recognizes method
<handle>, and, calls method <handle> of the event handler object 
with the event as single argument.

Function <process-pending-events> returns when no events are available on the
event queue.  Function <process-pending-events> is implicitely called whenever
events become available while Lush is waiting for user input on the console.
Long Lush programs can call this function from time to time in order to
maintain event driven graphic interface active during the execution of the
program.

#? (==> <eventhandler> handle <event>)
.SEE (process-pending-events) 
Method <handle> of event handler objects is automatically called
when lush dispatches events, either because it is waiting for
user input on the console, or because function <process-pending-events>
has been called.

#? ** Timers

#? (new Timer [<delay> [<interval>]] [<callback>])
Creates a new timer that fires every <interval> milliseconds after an initial
delay of <delay> milliseconds.  Specifying an interval of zero milliseconds
creates a one shot timer that fires only once after <delay> milliseconds.

A timer event is posted into the lush event queue when the timer fires.
This event is dispatched when lush waits for user input or when
function <process-pending-events> is called.  Dispatching the timer
event causes function <callback> to be called with
the timer as a single argument.

Example:
.CODE
? (new timer 1000 (lambda(c) (printf "One second\n"))))))
.PP
Timers only post events if the previously posted timer events
have been dispatched timely.  This feature prevents the event queue
to grow very large when lush is not able to dispatch the
events fast enough.

#? (==> <timer> set <delay> [<interval>])
Sets the timer delay <delay> and periodicity <interval> expressed in milliseconds.
Passing the empty list as argument <delay> cancels the timer.

#? (==> <timer> setcall <callback>)
Sets the timer callback function to <callback>.
This function is called whenever lush dispatches events generated
by this timer.

