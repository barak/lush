;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; LUSH Lisp Universal Shell
;;;   Copyright (C) 2002 Leon Bottou, Yann Le Cun, AT&T Corp, NECI.
;;; Includes parts of TL3:
;;;   Copyright (C) 1987-1999 Leon Bottou and Neuristique.
;;; Includes selected parts of SN3.2:
;;;   Copyright (C) 1991-2001 AT&T Corp.
;;;
;;; Includes information derived from the GSL (Gnu Scientific Library)
;;;   header files which are copyrighted and distributed under the GPL
;;;   by their respective authors.
;;;
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(libload "opencv/cv-config")



#? *** data_structures

;; dummy function that adds OpenCV C header files in C file
(eval `(de dummy_data_structures () ,cv-cpheader-cmd ()))

;; #? * (dummy_data_structures)
;; #? * (cvcreateimageheader <size> <depth> <channels>)
;; #? * (cvinitimageheader <image> <size> <depth> <channels> <origin> <align> <clear>)
;; #? * (cvcreateimage <size> <depth> <channels>)
;; #? * (cvreleaseimageheader <im>)
;; #? * (cvreleaseimage <im>)
;; #? * (cvcloneimage <im>)
;; #? * (cvsetimagecoi <im> <coi>)
;; #? * (cvgetimagecoi <im>)
;; #? * (cvsetimageroi <im> <rect>)
;; #? * (cvresetimageroi <im>)
;; #? * (cvgetimageroi <im> <rect>)
;; #? * (cvcreatematheader <rows> <cols> <type>)
;; #? * (cvinitmatheader <mat> <rows> <cols> <type> <data> <step>)
;; #? * (cvcreatemat <rows> <cols> <type>)
;; #? * (cvreleasematheader <mat>)
;; #? * (cvreleasemat <mat>)
;; #? * (cvclonemat <mat>)
;; #? * (cvgetsubarr <arr> <submat> <rect>)
;; #? * (cvgetrow <arr> <submat> <row>)
;; #? * (cvgetcol <arr> <submat> <column>)
;; #? * (cvgetdiag <arr> <submat> <diag>)
;; #? * (cvgetptrat <arr> <y> <x>)
;; #? * (cvgetat <arr> <y> <x> <s>)
;; #? * (cvsetat <arr> <value> <y> <x>)
;; #? * (cvgetmat <src> <header> <coi>)
;; #? * (cvgetimage <array> <img>)
;; #? * (cvreshape <array> <header> <new_cn> <new_rows>)
;; #? * (cvcreatedata <array>)
;; #? * (cvreleasedata <array>)
;; #? * (cvsetdata <array> <data> <step>)
;; #? * (cvgetrawdata <array> <data> <step> <roi_size>)
;; #? * (cvgetsize <arr> <size>)
;; #? * (cvcopy <src> <dst> <mask>)
;; #? * (cvset <arr> <scalar> <mask>)
;; #? * (cvlut <srcarr> <dstarr> <lutarr>)
;; #? * (cvpixsize <mattype>)
;; #? * (cvmget <mat> <i> <j>)
;; #? * (cvmset <mat> <i> <j> <val>)
;; #? * (cvcreateseq <seqflags> <hsize> <esize> <stor>)
;; #? * (cvsetseqblocksize <seq> <deltaelements>)
;; #? * (cvseqpush <seq> <element>)
;; #? * (cvseqpushfront <seq> <element>)
;; #? * (cvseqpop <seq> <element>)
;; #? * (cvseqpopfront <seq> <element>)
;; #? * (cvseqpushmulti <seq> <elements> <count>)
;; #? * (cvseqpopmulti <seq> <elements> <count>)
;; #? * (cvseqinsert <seq> <bindex> <element>)
;; #? * (cvseqremove <seq> <index>)
;; #? * (cvclearseq <seq>)
;; #? * (cvgetseqelem <seq> <index> <block>)
;; #? * (cvseqelemidx <seq> <element> <block>)
;; #? * (cvstartappendtoseq <seq> <writer>)
;; #? * (cvstartwriteseq <seqflags> <hsize> <esize> <stor> <writer>)
;; #? * (cvendwriteseq <writer>)
;; #? * (cvflushseqwriter <writer>)
;; #? * (cvstartreadseq <seq> <reader> <reverse>)
;; #? * (cvgetseqreaderpos <reader>)
;; #? * (cvsetseqreaderpos <reader> <index> <isrelative>)
;; #? * (cvcvtseqtoarray <seq> <array> <slice>)
;; #? * (cvmakeseqheaderforarray <seqtype> <hsize> <esize> <array> <total> <seq> <block>)
;; #? * (cvchangeseqblock <reader> <direction>)
;; #? * (cvcreateseqblock <writer>)
;; #? * (cvcreateset <setflags> <hsize> <esize> <stor>)
;; #? * (cvsetadd <setstruct> <element> <insertedelement>)
;; #? * (cvsetremove <setstruct> <index>)
;; #? * (cvgetsetelem <setstruct> <index>)
;; #? * (cvclearset <setstruct>)
;; #? * (cvcreategraph <graphflags> <hsize> <vtxsize> <esize> <stor>)
;; #? * (cvgraphaddvtx <graph> <vertex> <insertedvertex>)
;; #? * (cvgraphremovevtx <graph> <index>)
;; #? * (cvgraphremovevtxbyptr <graph> <vtx>)
;; #? * (cvgraphaddedge <graph> <sidx> <eidx> <edge> <insertededge>)
;; #? * (cvgraphaddedgebyptr <graph> <svtx> <evtx> <edge> <insertededge>)
;; #? * (cvgraphremoveedge <graph> <sidx> <eidx>)
;; #? * (cvgraphremoveedgebyptr <graph> <svtx> <evtx>)
;; #? * (cvfindgraphedge <graph> <sidx> <eidx>)
;; #? * (cvfindgraphedgebyptr <graph> <svtx> <evtx>)
;; #? * (cvcleargraph <graph>)
;; #? * (cvgraphvtxdegree <graph> <vtxidx>)

;; ********************************************************




;;*******************************************************************************************
;;             1.    functions for IplImage
;;
;;*******************************************************************************************

#? (cvCreateImageHeader  <size> <depth> <channels>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCreateImageHeader
;;  //    Purpose: allocates IplImage structure, initializes and returns it
;;  //    Context:
;;  //    Parameters:
;;  //      size - image size(width and height)
;;  //      depth- image depth
;;  //      channels - number of channels.
;;  //    Returns:
;;  //      created image header
;;  //    Notes:
;;  //      this call is short form of
;;  //         iplCreateImageHeader( channels, 0, depth, channels == 1 ? "GRAY" :
;;  //                               channels == 3 || channels == 4 ? "RGB" : "",
;;  //                               channels == 1 ? "GRAY" : channels == 3 ? "BGR" :
;;  //                               channels == 4 ? "BGRA" : "",
;;  //                               IPL_DATA_ORDER_PIXEL, IPL_ORIGIN_TL, 4,
;;  //                               size.width, size.height,
;;  //                               0,0,0,0);
;;  //F*/
;;  OPENCVAPI  IplImage*  cvCreateImageHeader( CvSize size, int depth, int channels );

(de cvCreateImageHeader (size depth channels)
    ((-gptr- "CvSize *") size)
    ((-int-) depth)
    ((-int-) channels)
    (let ((im (gptr ())))
      #{ $im = (IplImage *) cvCreateImageHeader(*$size, $depth, $channels);  #}
      im))

#? (cvInitImageHeader  <image> <size> <depth> <channels> <origin> <align> <clear>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvInitImageHeader
;;  //    Purpose: initializes image header structure without memory allocation
;;  //    Context:
;;  //    Parameters:
;;  //      image - image header. User allocates it manually(e.g. on the stack)
;;  //      size  - width and height of the image
;;  //      depth - image depth
;;  //      channels - number of channels
;;  //      origin - IPL_ORIGIN_TL or IPL_ORIGIN_BL.
;;  //      align - alignment for raster lines
;;  //    Returns:
;;  //      initialized header
;;  //F*/
;;  OPENCVAPI IplImage* cvInitImageHeader( IplImage* image, CvSize size, int depth,
;;                                         int channels, int origin CV_DEFAULT(0),
;;                                         int align CV_DEFAULT(4));

(de cvInitImageHeader (image size depth channels origin align)
    ((-gptr- "IplImage *") image)
    ((-gptr- "CvSize *") size)
    ((-int-) depth)
    ((-int-) channels)
    ((-int-) origin)
    ((-int-) align)
    (let ((im (gptr ())))
      #{ $im = (IplImage *)cvInitImageHeader($image, *$size, $depth, $channels, $origin, $align); #}
      im))

#? (cvCreateImage  <size> <depth> <channels>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCreateImage
;;  //    Purpose: creates image header and allocates data
;;  //    Context:
;;  //    Parameters:
;;  //      size - image size(width and height)
;;  //      depth- image depth
;;  //      channels - number of channels.
;;  //    Returns:
;;  //      created image
;;  //    Notes:
;;  //      this call is short form of
;;  //         header = cvCreateImageHeader(size,depth,channels);
;;  //         cvCreateData(header);
;;  //F*/
;;  OPENCVAPI  IplImage*  cvCreateImage( CvSize size, int depth, int channels );

(de cvCreateImage (size depth channels)
    ((-gptr- "CvSize *") size)
    ((-int-) depth)
    ((-int-) channels)
    (let ((im (gptr ())))
      #{ $im = (IplImage *)cvCreateImage(*$size, $depth, $channels); #}
      im))

#? (cvReleaseImageHeader  <im>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvReleaseImageHeader
;;  //    Purpose: releases header
;;  //    Context:
;;  //    Parameters:
;;  //        image - released image header
;;  //    Returns:
;;  //      this call is short form of
;;  //         if( image )
;;  //         {
;;  //              iplDeallocate( *image, IPL_IMAGE_HEADER | IPL_IMAGE_ROI );
;;  //              *image = 0;
;;  //         }
;;  //F*/
;;  OPENCVAPI  void  cvReleaseImageHeader( IplImage** image );

(de cvReleaseImageHeader (im)
    ((-gptr- "IplImage **") im)
    #{ cvReleaseImageHeader($im); #}
    ())

#? (cvReleaseImage  <im>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvReleaseImage
;;  //    Purpose: releases header and image data
;;  //    Context:
;;  //    Parameters:
;;  //      image - released image
;;  //    Returns:
;;  //      this call is short form of
;;  //         if( image && *image )
;;  //         {
;;  //              iplDeallocate( *image, IPL_IMAGE_ALL );
;;  //              *image = 0;
;;  //         }
;;  //F*/
;;  OPENCVAPI  void  cvReleaseImage( IplImage** image );

(de cvReleaseImage (im)
    ((-gptr- "IplImage **") im)
    #{ cvReleaseImage($im) ; #}
    ())

#? (cvCloneImage  <im>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCloneImage
;;  //    Purpose: creates a whole copy of the image
;;  //    Context:
;;  //    Parameters:
;;  //      image - source image
;;  //    Returns:
;;  //    Notes:
;;  //F*/
;;  OPENCVAPI IplImage* cvCloneImage( const IplImage* image );

(de cvCloneImage (im)
    ((-gptr- "const IplImage *") im)
    (let ((val (gptr ())))
      #{  $val = (IplImage *)cvCloneImage($im); #}
      val))

#? (cvSetImageCOI  <im> <coi>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSetImageCOI
;;  //    Purpose: set channel of interest to given value.
;;  //    Context:
;;  //    Parameters:
;;  //      image - image header
;;  //      coi   - channel of interest
;;  //    Returns:
;;  //    Notes:
;;  //      If roi is NULL and coi != 0, roi is allocated.
;;  //F*/
;;  OPENCVAPI  void  cvSetImageCOI( IplImage* image, int coi );

(de cvSetImageCOI (im coi)
    ((-gptr- "IplImage *") im)
    ((-int-) coi)
    #{ cvSetImageCOI($im,$coi); #}
    ())


#? (cvGetImageCOI  <im>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGetImageCOI
;;  //    Purpose: retrieves channel of interest
;;  //    Context:
;;  //    Parameters:
;;  //      image - image header
;;  //    Returns:
;;  //      COI
;;  //F*/
;;  OPENCVAPI  int  cvGetImageCOI( IplImage* image );

(de cvGetImageCOI (im)
    ((-gptr- "IplImage *") im)
    (let ((coi 0))
      ((-int-) coi)
      #{  $coi = cvGetImageCOI($im); #}
      coi))

#? (cvSetImageROI  <im> <rect>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSetImageROI
;;  //    Purpose: set image ROI to given rectangle
;;  //    Context:
;;  //    Parameters:
;;  //      image - image header
;;  //      rect  - ROI rectangle
;;  //    Returns:
;;  //    Notes:
;;  //       If roi is NULL and rect is not equal to a whole image, roi is allocated.
;;  //F*/
;;  OPENCVAPI  void  cvSetImageROI( IplImage* image, CvRect rect );

(de cvSetImageROI (im rect)
    ((-gptr- "IplImage *") im)
    ((-gptr- "CvRect *") rect)
    #{  cvSetImageROI($im, *$rect);  #}
    ())

#? (cvResetImageROI  <im>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvResetImageROI
;;  //    Purpose: deletes image ROI
;;  //    Context:
;;  //    Parameters:
;;  //      image - image header
;;  //    Returns:
;;  //    Notes:
;;  //F*/
;;  OPENCVAPI  void  cvResetImageROI( IplImage* image );

(de cvResetImageROI (im)
    ((-gptr- "IplImage *") im)
    #{ cvResetImageROI($im);  #}
    ())

#? (cvGetImageROI  <im> <rect>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGetImageROI
;;  //    Purpose: return region of interest (ROI) for given image or
;;  //             (0,0,image->width,image->height) if ROI is not set
;;  //    Context:
;;  //    Parameters:
;;  //      image - image header
;;  //    Returns:
;;  //    Notes:
;;  //F*/
;;  OPENCVAPI  CvRect cvGetImageROI( const IplImage* image );

(de cvGetImageROI (im rect)
    ((-gptr- "const IplImage *") im)
    ((-gptr- "CvRect *") rect)
    #{  { 
    CvRect tmp;
    tmp = cvGetImageROI($im);
    memcpy($rect,&tmp,sizeof(CvRect));
    } #}
    ())
    



;;*******************************************************************************************
;;                       2. functions for CvMat 
;;
;;*******************************************************************************************


#? (cvCreateMatHeader  <rows> <cols> <type>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCreateMatHeader
;;  //    Purpose: allocates CvMat structure, initializes and returns it
;;  //    Context:
;;  //    Parameters:
;;  //      rows - number of matrix rows
;;  //      cols - number of matrix columns
;;  //      type - matrix type
;;  //      step - matrix step (or stride) - an optional parameter.
;;  //    Returns:
;;  //      created matrix header
;;  //F*/
;;  OPENCVAPI  CvMat*  cvCreateMatHeader( int rows, int cols, int type );

(de cvCreateMatHeader (rows cols type)
    ((-int-) rows)
    ((-int-) cols)
    ((-int-) type)
    (let ((m (gptr ())))
      #{  $m = (CvMat *)cvCreateMatHeader($rows, $cols, $type); #}
      m))

#? (cvInitMatHeader <mat> <rows> <cols> <type> <data> <step>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvInitMatHeader
;;  //    Purpose: initializes matrix header structure without memory allocation
;;  //    Context:
;;  //    Parameters:
;;  //      mat   - matrix header. User allocates it manually(e.g. on the stack)
;;  //      rows  - number of matrix rows
;;  //      cols  - number of matrix columns
;;  //      type  - matrix type
;;  //      step  - matrix step (optional)
;;  //    Returns:
;;  //      initalized matrix header
;;  //F*/
;;  OPENCVAPI CvMat* cvInitMatHeader( CvMat* mat, int rows, int cols,
;;                                    int type, void* data CV_DEFAULT(0),
;;                                    int step CV_DEFAULT(CV_AUTOSTEP) );

(de cvInitMatHeader(mat rows cols type data step)
    ((-gptr- "CvMat *") mat)
    ((-int-) rows)
    ((-int-) cols)
    ((-int-) type)
    ((-gptr-) data)
    ((-int-) step)
    (let ((m (gptr ())))
      #{  $m = (CvMat *)cvInitMatHeader($mat, $rows, $cols, $type, $data, $step);  #}
      m))

#? (cvCreateMat <rows> <cols> <type>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCreateMat
;;  //    Purpose: creates matrix header and allocates data
;;  //    Context:
;;  //    Parameters:
;;  //      rows  - number of matrix rows
;;  //      cols  - number of matrix columns
;;  //      type  - matrix type
;;  //      step  - matrix step (optional)
;;  //    Returns:
;;  //      created matrix
;;  //F*/
;;  OPENCVAPI  CvMat*  cvCreateMat( int rows, int cols, int type );

(de cvCreateMat(rows cols type)
    ((-int-) rows)
    ((-int-) cols)
    ((-int-) type)
    (let ((m (gptr ())))
      #{  $m = (CvMat *)cvCreateMat($rows, $cols, $type);  #}
      m))

#? (cvReleaseMatHeader <mat>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvReleaseMatHeader
;;  //    Purpose: releases matrix header
;;  //    Context:
;;  //    Parameters:
;;  //        mat - released matrix header
;;  //    Returns:
;;  //      nothing
;;  //F*/
;;  OPENCVAPI  void  cvReleaseMatHeader( CvMat** mat );

(de cvReleaseMatHeader(mat)
    ((-gptr- "CvMat **") mat)
    #{  cvReleaseMatHeader($mat); #}
    ())

#? (cvReleaseMat  <mat>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvReleaseMat
;;  //    Purpose: releases matrix header and underlying data
;;  //    Context:
;;  //    Parameters:
;;  //      matrix - released matrix
;;  //    Returns:
;;  //      nothing
;;  //    Notes:
;;  //F*/
;;  OPENCVAPI  void  cvReleaseMat( CvMat** mat );

(de cvReleaseMat (mat)
    ((-gptr- "CvMat **") mat)
    #{  cvReleaseMat($mat);  #}
    ())

#? (cvCloneMat  <mat>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCloneMat
;;  //    Purpose: creates a whole copy of the matrix
;;  //    Context:
;;  //    Parameters:
;;  //      mat - the cloned matrix
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI CvMat* cvCloneMat( const CvMat* mat );

(de cvCloneMat (mat)
    ((-gptr- "const CvMat *") mat)
    (let ((nmat (gptr ())))
      #{ $nmat = (CvMat *)cvCloneMat($mat);  #}
    nmat))

    
#? (cvGetSubArr   <arr> <submat> <rect>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGetSubArr
;;  //    Purpose: returns sub-matrix w.o copying data
;;  //    Context:
;;  //    Parameters:
;;  //      arr - the original matrix (or IplImage)
;;  //      submat - pointer to sub-matrix stucture
;;  //      rect - extracted rectange
;;  //    Returns:
;;  //      filled header of submatrix (i.e., &submat)
;;  //F*/
;;  OPENCVAPI CvMat* cvGetSubArr( const CvArr* arr, CvMat* submat, CvRect rect );

(de cvGetSubArr ( arr submat rect)
    ((-gptr- "const CvArr *") arr)
    ((-gptr- "CvMat *") submat)
    ((-gptr- "CvRect *") rect)
    (let ((nmat (gptr ())))
      #{ $nmat = (CvMat *) cvGetSubArr($arr, $submat, *$rect);  #}
      nmat))

#? (cvGetRow  <arr> <submat> <row>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGetRow
;;  //    Purpose: The function is analogous to the previous, but returns a single row
;;  //    Context:
;;  //    Parameters:
;;  //      arr - an original matrix (or IplImage)
;;  //      submat - pointer to sub-matrix stucture
;;  //      row - index of the row
;;  //    Returns:
;;  //      filled header of sub-matrix (i.e., &submat)
;;  //F*/
;;  OPENCVAPI CvMat* cvGetRow( const CvArr* arr, CvMat* submat, int row );

(de cvGetRow (arr submat row)
    ((-gptr- "const CvArr *") arr)
    ((-gptr- "CvMat *") submat)
    ((-int-) row)
    (let ((nmat (gptr ())))
      #{ $nmat = (CvMat *) cvGetRow($arr, $submat, $row);  #}
      nmat))

#? (cvGetCol <arr> <submat> <column>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGetCol
;;  //    Purpose: The function is analogous to the previous, but returns a single column
;;  //    Context:
;;  //    Parameters:
;;  //      arr - an original matrix (or IplImage)
;;  //      submat - pointer to sub-matrix stucture
;;  //      column - index of the column
;;  //    Returns:
;;  //      filled header of sub-matrix (i.e., &submat)
;;  //F*/
;;  OPENCVAPI CvMat* cvGetCol( const CvArr* arr, CvMat* submat, int column );

(de cvGetCol(arr submat column)
    ((-gptr- "const CvArr *") arr)
    ((-gptr- "CvMat *") submat)
    ((-int-) column)
    (let ((nmat (gptr ())))
      #{  $nmat = (CvMat *) cvGetCol($arr, $submat, $column); #}
      nmat))

#? (cvGetDiag  <arr> <submat> <diag>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGetCol
;;  //    Purpose: The function is analogous to the previous, but returns a single diagonal
;;  //    Context:
;;  //    Parameters:
;;  //      arr - an original matrix (or IplImage)
;;  //      submat - pointer to sub-matrix stucture
;;  //      diag - index of the diagonal ( 0 corresponds to the main diagonal,
;;  //                positive number - to some upper diagonal, negative number - to
;;  //                some lower diagonal ), as shown below:
;;  //             0  1  2  3  4
;;  //            -1  0  1  2  3
;;  //            -2 -1  0  1  2
;;  //            -3 -2 -1  0  1
;;  //            -4 -3 -2 -1  0
;;  //            -5 -4 -3 -2 -1
;;  //
;;  //    Returns:
;;  //      filled header of sub-matrix (i.e., &submat)
;;  //F*/
;;  CVAPI CvMat* cvGetDiag( const CvArr* arr, CvMat* submat, int diag CV_DEFAULT(0));

(de cvGetDiag( arr submat diag)
    ((-gptr- "const CvArr *") arr)
    ((-gptr- "CvMat *") submat)
    ((-int-) diag)
    (let ((nmat (gptr ())))
      #{  $nmat = (CvMat *)cvGetDiag($arr, $submat,$diag);  #}
      nmat))

;;                           
;;  /* ptr = &arr(idx) */
;;  CVAPI int cvGetElemType(const CvArr* arr);

(de cvGetElemType(arr)
    ((-gptr- "const CvArr *") arr)
    (let ((type 0))
      #{  $type = (int)cvGetElemType($arr);  #}
      type))

;;                           
;;  /* ptr = &arr(idx) */
;;  CVAPI int cvGetDims(const CvArr* arr, int* indexes);

(de cvGetDims(arr inds)
    ((-gptr- "const CvArr *") arr)
    ((-gptr- "int *") inds)
    (let ((siz 0))
      #{  $siz = (int)cvGetDims($arr, $inds);  #}
      siz))

;;                           
;;  /* ptr = &arr(idx) */
;;  CVAPI int cvGetDimSize(const CvArr* arr, int index);

(de cvGetDimSize(arr ind)
    ((-gptr- "const CvArr *") arr)
    ((-int-) ind)
    (let ((siz 0))
      #{  $siz = (int)cvGetDimSize($arr, $ind);  #}
      siz))

;;                           
;;  /* ptr = &arr(idx) */
;;  CVAPI uchar* cvPtr1D(const CvArr* arr, int y, int x, int* type CV_DEFAULT(NULL));

(de cvPtr1D(arr x type)
    ((-gptr- "const CvArr *") arr)
    ((-int-) x)
    ((-gptr- "int *") type)
    (let ((v (gptr ())))
      #{   $v = (uchar *) cvPtr1D($arr, $x, $type);  #}
      v))
      
;;  /* value = arr(idx) */
;;  CVAPI CvScalar cvGet1D(const CvArr* arr, int x); 

(de cvGet1D(arr x s)
    ((-gptr- "const CvArr *") arr)
    ((-int-) x)
    ((-gptr- "CvScalar *") s)
    #{  {  CvScalar tmp;
      tmp = cvGet1D($arr, $x);
      memcpy($s, &tmp, sizeof(CvScalar)); } #}
      ())

;;  /* arr(idx) = value */
;;  CVAPI void cvSet1D( CvArr* arr, int x, CvScalar value);

(de cvSet1D(arr x value)
    ((-gptr- "CvArr *") arr)
    ((-gptr- "CvScalar *") value)
    ((-int-) x)
    #{  cvSet1D($arr, $x, *$value);  #}
    ())

;;  /* value = arr(idx) */
;;  CVAPI double cvGetReal1D(const CvArr* arr, int x); 

(de cvGetReal1D(arr x)
    ((-gptr- "const CvArr *") arr)
    ((-int-) x)
    (let ((v 0))
      #{ $v = (double) cvGetReal1D($arr, $x);  #}
      v))

;;  /* arr(idx) = value */
;;  CVAPI void cvSetReal1D( CvArr* arr, int x, double value);

(de cvSetReal1D(arr x value)
    ((-gptr- "CvArr *") arr)
    ((-double-) value)
    ((-int-) x)
    #{  cvSetReal1D($arr, $x, $value);  #}
    ())

;;                           
;;  /* ptr = &arr(idx) */
;;  CVAPI uchar* cvPtr2D(const CvArr* arr, int y, int x, int* type CV_DEFAULT(NULL));

(de cvPtr2D(arr y x type)
    ((-gptr- "const CvArr *") arr)
    ((-int-) y)
    ((-int-) x)
    ((-gptr- "int *") type)
    (let ((v (gptr ())))
      #{   $v = (uchar *) cvPtr2D($arr, $y, $x, $type);  #}
      v))
      
;;  /* value = arr(idx) */
;;  CVAPI CvScalar cvGet2D(const CvArr* arr, int y, int x); 

(de cvGet2D(arr y x s)
    ((-gptr- "const CvArr *") arr)
    ((-int-) y)
    ((-int-) x)
    ((-gptr- "CvScalar *") s)
    #{  {  CvScalar tmp;
      tmp = cvGet2D($arr, $y, $x);
      memcpy($s, &tmp, sizeof(CvScalar)); } #}
      ())

;;  /* arr(idx) = value */
;;  CVAPI void cvSet2D( CvArr* arr, int y, int x, CvScalar value);

(de cvSet2D(arr y x value)
    ((-gptr- "CvArr *") arr)
    ((-gptr- "CvScalar *") value)
    ((-int-) y)
    ((-int-) x)
    #{  cvSet2D($arr, $y, $x, *$value);  #}
    ())

;;  /* value = arr(idx) */
;;  CVAPI double cvGetReal2D(const CvArr* arr, int x); 

(de cvGetReal2D(arr y x)
    ((-gptr- "const CvArr *") arr)
    ((-int-) x)
    ((-int-) y)
    (let ((v 0))
      #{ $v = (double) cvGetReal2D($arr, $y, $x);  #}
      v))

;;  /* arr(idx) = value */
;;  CVAPI void cvSetReal2D( CvArr* arr, int y, int x, double value);

(de cvSetReal2D(arr y x value)
    ((-gptr- "CvArr *") arr)
    ((-double-) value)
    ((-int-) x)
    ((-int-) y)
    #{  cvSetReal2D($arr, $y, $x, $value);  #}
    ())

;;  /* Converts CvArr (IplImage or CvMat) to CvMat */
;;  CVAPI CvMat* cvGetMat( const CvArr* src, CvMat* header, int* coi CV_DEFAULT(NULL), int allowND CV_DEFAULT(0));

(de cvGetMat(src header coi allownd)
    ((-gptr- "const CvArr *") src)
    ((-gptr- "CvMat *") header)
    ((-gptr- "int *") coi)
    ((-int-) allownd)
    (let ((nmat (gptr ())))
      ((-gptr- "CvMat *") nmat)
      #{ $nmat = (CvMat *)cvGetMat($src, $header, $coi, $allownd);  #}
      nmat))

;;  /* Converts CvArr (IplImage or CvMat) to IplImage */
;;  CVAPI IplImage* cvGetImage( const CvArr* array, IplImage* img );

(de cvGetImage(array img)
    ((-gptr- "const CvArr *") array)
    ((-gptr- "IplImage *") img)
    (let ((im (gptr ())))
      ((-gptr- "IplImage *") im)
      #{  $im = (IplImage *)cvGetImage($array, $img);  #}
      im))

#? (cvReshape <array> <header> <new_cn> <new_rows>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvReshape
;;  //    Purpose: reshapes the matrix
;;  //    Context:
;;  //    Parameters:
;;  //      array  - image or matrix
;;  //      header - the output matrix header (may be the same as input)
;;  //      new_cn - the new channel number. The original array width multiplied by the
;;  //               original number of channels should be divisible
;;  //               by the new number of channels.
;;  //      new_rows - the new number of rows in the matrix. 0 means do not change it if
;;  //               it is not neccessary. Number of rows can be changed only if the matrix
;;  //               continuous.
;;  //    Returns:
;;  //    Notes:
;;  //      All the output parameters are optional
;;  //F*/
;;  CVAPI CvMat* cvReshape( const CvArr* array, CvMat* header,
;;                              int new_cn, int new_rows CV_DEFAULT(0));

(de cvReshape(array header new_cn new_rows)
    ((-gptr- "const CvArr *") array)
    ((-gptr- "CvMat *") header)
    ((-int-) new_cn)
    ((-int-) new_rows)
    (let ((nmat (gptr ())))
      ((-gptr- "CvArr *") nmat)
      #{  $nmat = (CvMat *) cvReshape($array, $header, $new_cn, $new_rows);  #}
      nmat))

#? (cvCreateData  <array>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCreateData
;;  //    Purpose: allocates image or matrix data
;;  //    Context:
;;  //    Parameters:
;;  //        array - image or matrix header
;;  //F*/
;;  OPENCVAPI  void  cvCreateData( CvArr* array );

(de cvCreateData (array)
    ((-gptr- "CvArr *") array)
    #{  cvCreateData($array);  #}
    ())

#? (cvReleaseData <array>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvReleaseData
;;  //    Purpose: releases image data
;;  //    Context:
;;  //    Parameters:
;;  //      array - image or matrix header
;;  //F*/
;;  OPENCVAPI  void  cvReleaseData( CvArr* array );
(de cvReleaseData(array)
    ((-gptr- "CvArr *") array)
    #{   cvReleaseData($array);   #}
    ())

#? (cvSetData <array> <data> <step>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSetData
;;  //    Purpose: sets pointer to data and step parameter to given values
;;  //    Context:
;;  //    Parameters:
;;  //      array - image or matrix header
;;  //      data  - user data
;;  //      step  - full width or data (distance between successive rows)
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void  cvSetData( CvArr* array, void* data, int step );

(de cvSetData(array data step)
    ((-gptr- "CvArr *") array)
    ((-gptr-) data)
    ((-int-) step)
    #{   cvSetData($array, $data, $step);  #}
    ())

#? (cvGetRawData <array> <data> <step> <roi_size>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGetRawData
;;  //    Purpose: fills output variables with image parameters
;;  //    Context:
;;  //    Parameters:
;;  //      array - image or matrix
;;  //      data  - pointer to top-left corner of ROI
;;  //      step  - is set to <widthStep> field in case of IplImage or
;;  //              to <step> field in case of CvMat
;;  //      roi_size - width and height of ROI
;;  //    Returns:
;;  //    Notes:
;;  //      All the output parameters are optional
;;  //F*/
;;  OPENCVAPI void cvGetRawData( const CvArr* array, uchar** data,
;;                               int* step, CvSize* roi_size );

(de cvGetRawData(array data step roi_size)
    ((-gptr- "const CvArr *") array)
    ((-gptr- "uchar **") data)
    ((-gptr- "int *") step)
    ((-gptr- "CvSize *") roi_size)
    #{  cvGetRawData($array, $data, $step, $roi_size);  #}
    ())

#? (cvGetSize <arr> <size>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGetSize
;;  //    Purpose: returns size of matrix or image ROI.
;;  //             in case of matrix size.width == number_of_columns,
;;  //                               size.height == number_of_rows.
;;  //    Context:
;;  //    Parameters:
;;  //      arr - image or matrix
;;  //    Returns:
;;  //    Notes:
;;  //F*/
;;  OPENCVAPI  CvSize cvGetSize( const CvArr* arr );

(de cvGetSize(arr size)
    ((-gptr- "const CvArr *") arr)
    ((-gptr- "CvSize *") size)
    #{ { CvSize tmp;
    tmp = cvGetSize($arr);  
    memcpy($size, &tmp, sizeof(CvSize));  } #}
    ())

#? (cvCopy <src> <dst> <mask>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCopy
;;  //    Purpose: copies image ROI or matrix
;;  //    Context:
;;  //    Parameters:
;;  //      src - source array
;;  //      dst - destination array
;;  //      mask - optional mask
;;  //F*/
;;  OPENCVAPI  void  cvCopy( const CvArr* src, CvArr* dst,
;;                           const CvArr* mask CV_DEFAULT(0) );

(de cvCopy(src dst mask)
    ((-gptr- "const CvArr *") src)
    ((-gptr- "CvArr *") dst)
    ((-gptr- "const CvArr *") mask)
    #{ cvCopy($src, $dst, $mask);  #}
    ())

#? (cvSet  <arr> <scalar> <mask>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSet
;;  //    Purpose: sets image ROI or matrix to given value
;;  //    Context:
;;  //    Parameters:
;;  //      arr - array
;;  //      scalar - value to set to
;;  //      mask - optional mask
;;  //F*/
;;  OPENCVAPI  void  cvSet( CvArr* arr, CvScalar scalar,
;;                          const CvArr* mask CV_DEFAULT(0) );

(de cvSet (arr scalar mask)
    ((-gptr- "CvArr *") arr)
    ((-gptr- "CvScalar *") scalar)
    ((-gptr- "const CvArr *") mask)
    #{  cvSet($arr, *$scalar, $mask);  #}
    ())

#? (cvLUT  <srcarr> <dstarr> <lutarr>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvLUT
;;  //    Purpose: Performs lookup-table transform: dst(x,y) = lut[src(x,y)]
;;  //    Parameters:
;;  //      srcarr - the source array: 8u or 8s type
;;  //      dstarr - the destination array of arbitrary type,
;;  //      lutarr - the LUT array. The same type as the destination array,
;;  //               contains 256 entries.
;;  //    Note:
;;  //      if the source array has 8s type, the modified formula is used:
;;  //      dst(x,y) = lut[src(x,y) + 128]
;;  //F*/
;;  OPENCVAPI  void cvLUT( const CvArr* srcarr, CvArr* dstarr, const CvArr* lutarr );

(de cvLUT (srcarr dstarr lutarr)
    ((-gptr- "const CvArr *") srcarr)
    ((-gptr- "CvArr *") dstarr)
    ((-gptr- "const CvArr *") lutarr)
    #{   cvLUT($srcarr, $dstarr, $lutarr);  #}
    ())


(de cvmGet (mat i j)
    ((-gptr- "const CvMat *") mat)
    ((-int-) i)
    ((-int-) j)
    (let ((val 0))
      ((-double-) val)
      #{  $val = cvmGet($mat,$i,$j); #}
      val))



(de cvmSet ( mat i j val)
     ((-gptr- "CvMat *") mat)
     ((-int-) i)
     ((-int-) j)
     ((-double-) val)
     #{ cvmSet($mat,$i,$j,$val);   #}
     ())




;;************************************************************************************************
;;                     3. functions on CvSeq
;;
;;************************************************************************************************

;; Jie's comments:  this CvSeq structure is a complicated dynamic array
;; the elements stored in CvSeq have to be homogeneous (therefore you can query element size) .
;; CvSeq has multiple fixed size arrays indexed by a double-linked list,
;; it "grows" by allocating a new fixed size array and append it to the list
;; therefore, accessing one element by index is not very efficent.
;; the index can be negative, or larger than total number of elements, in these cases, 
;; the index will be modulated by total.
;; accessing function cvGetSeqElem is wrapped into a macro CV_GET_SEQ_ELEM,
;; accessing is inefficient, a "reader" structure can be used to speed up the accessing.
;; the bookkeeping information in the reader CvSeqReader must be updated so that you get what you
;; really want. you can update the reader information by using macro CV_NEXT_SEQ_ELEM / CV_PREV_SEQ_ELEM,
;; and accessing via reader is done with macro CV_READ_SEQ_ELEM / CV_REV_READ_SEQ_ELEM
;; there's another structure CvChainPtReader, based on CvSeqReader, specifically designed to read 
;; CvChain sequences.
;; the CvSet, CvGraph and CvChain are both based on CvSeq


#? (cvCreateSeq  <seqflags> <hsize> <esize> <stor>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCreateSeq
;;  //    Purpose: creates sequence, located on the storage
;;  //    Context:
;;  //    Parameters:
;;  //         seq_flags - flags of created sequence
;;  //         header_size - size of sequence header. Must be non-less than sizeof(CvSeq)
;;  //         elem_size - size of sequence elements
;;  //         storage - memory storage
;;  //    Returns:
;;  //      created sequence
;;  //    Notes:
;;  //F*/
;;  OPENCVAPI  CvSeq*  cvCreateSeq( int seq_flags, int header_size,
;;                               int elem_size, CvMemStorage* storage );

(de cvCreateSeq (seqflags hsize esize stor)
    ((-int-) seqflags hsize esize)
    ((-gptr- "CvMemStorage *") stor)
    (let ((s (gptr ())))
      #{ $s = (CvSeq *) cvCreateSeq($seqflags, $hsize, $esize, $stor); #}
      s))

#? (cvSetSeqBlockSize <seq> <deltaelements>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSetSeqBlockSize
;;  //    Purpose: adjusts granularity of memory allocation for sequence
;;  //    Context:
;;  //    Parameters:
;;  //         seq - sequence pointer
;;  //         delta_elements - how many elements to allocate when there is no free space
;;  //                          in the sequence.
;;  //    Returns:
;;  //    Notes:
;;  //      If this function is not called after sequence is created,
;;  //      delta_elements is set to ~1K/elem_size
;;  //F*/
;;  OPENCVAPI  void  cvSetSeqBlockSize( CvSeq* seq, int delta_elements );

(de cvSetSeqBlockSize(seq deltaelements)
    ((-gptr- "CvSeq *") seq)
    ((-int-) deltaelements)
    #{ cvSetSeqBlockSize($seq, $deltaelements); #}
    ())

#? (cvSeqPush <seq> <element>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSeqPush
;;  //    Purpose: adds element in the end of sequence
;;  //    Context:
;;  //    Parameters:
;;  //         seq - sequence pointer
;;  //         element - added element
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  char*  cvSeqPush( CvSeq* seq, void* element CV_DEFAULT(0));

(de cvSeqPush(seq element)
    ((-gptr- "CvSeq *") seq)
    ((-gptr-) element)
    (let ((s (gptr ())))
      #{ $s = (char *) cvSeqPush($seq, $element); #}
      s))

#? (cvSeqPushFront  <seq> <element>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSeqPushFront
;;  //    Purpose: adds element in the beginning of sequence
;;  //    Context:
;;  //    Parameters:
;;  //         seq     - sequence pointer
;;  //         element - added element
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  char*  cvSeqPushFront( CvSeq* seq, void* element CV_DEFAULT(0));

(de cvSeqPushFront (seq element)
    ((-gptr- "CvSeq *") seq)
    ((-gptr-) element)
    (let ((s (gptr ())))
      #{ $s = (char *) cvSeqPushFront($seq, $element); #}
      s))

#? (cvSeqPop <seq> <element>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSeqPop
;;  //    Purpose: removes element from the end of sequence
;;  //    Context:
;;  //    Parameters:
;;  //         seq     - sequence pointer
;;  //         element - optional parameter. If pointer is not NULL,
;;  //                   removed element is copied there.
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void  cvSeqPop( CvSeq* seq, void* element );

(de cvSeqPop(seq element)
    ((-gptr- "CvSeq *") seq)
    ((-gptr-) element)
    #{ cvSeqPop($seq, $element); #}
    ())

#? (cvSeqPopFront <seq> <element>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSeqPopFront
;;  //    Purpose: removes element from the beginning of sequence
;;  //    Context:
;;  //    Parameters:
;;  //         seq     - sequence pointer
;;  //         element - optional parameter. If pointer is not NULL,
;;  //                   removed element is copied there.
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void  cvSeqPopFront( CvSeq* seq, void* element );

(de cvSeqPopFront(seq element)
    ((-gptr- "CvSeq *") seq)
    ((-gptr-) element)
    #{ cvSeqPopFront($seq, $element); #}
    ())

#? (cvSeqPushMulti <seq> <elements> <count> <in-front>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSeqPushMulti
;;  //    Purpose: adds several elements in the end of sequence
;;  //    Context:
;;  //    Parameters:
;;  //         seq      - sequence pointer
;;  //         count    - number of added elements
;;  //         elements - array of added elements.
;;  //         in_front - 1 if push in front
;;  //    Returns:
;;  //F*/
;;  CVAPI  void  cvSeqPushMulti(CvSeq* seq, void* elements, int count, int in_front);

(de cvSeqPushMulti(seq elements count in-front)
    ((-gptr- "CvSeq *") seq)
    ((-gptr-) elements)
    ((-int-) count in-front)
    #{ cvSeqPushMulti($seq, $elements, $count, $in_front); #}
    ())

#? (cvSeqPopMulti <seq> <elements> <count> <in-fron>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSeqPopMulti
;;  //    Purpose: removes several elements from the end of sequence
;;  //    Context:
;;  //    Parameters:
;;  //         seq      - sequence pointer
;;  //         count    - number of removed elements
;;  //         elements - optional parameter. If not NULL, removed elements are copied there
;;  //         in_front - 1 if pop in front
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void  cvSeqPopMulti( CvSeq* seq, void* elements, int count, int in_front);

(de cvSeqPopMulti(seq elements count in-front)
    ((-gptr- "CvSeq *") seq)
    ((-gptr-) elements)
    ((-int-) count in-front)
    #{ cvSeqPopMulti($seq, $elements, $count, $in_front); #}
    ())

#? (cvSeqInsert <seq> <bindex> <element>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSeqInsert
;;  //    Purpose: inserts element in the middle of the sequence
;;  //    Context:
;;  //    Parameters:
;;  //         sequence     - sequence pointer
;;  //         before_index - index of element, before which the element is inserted
;;  //         element      - inserted element
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  char*  cvSeqInsert( CvSeq* seq, int before_index,
;;                                 void* element CV_DEFAULT(0));

(de cvSeqInsert(seq bindex element)
    ((-gptr- "CvSeq *") seq)
    ((-int-) bindex)
    ((-gptr-) element)
    (let ((s (gptr ())))
      #{ $s = (char *) cvSeqInsert($seq, $bindex, $element); #}
      s))

#? (cvSeqRemove <seq> <index>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSeqRemove
;;  //    Purpose: removes element from the middle of the sequence
;;  //    Context:
;;  //    Parameters:
;;  //         seq      - sequence pointer
;;  //         index    - index of removed element
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void  cvSeqRemove( CvSeq* seq, int index );

(de cvSeqRemove(seq index)
    ((-gptr- "CvSeq *") seq)
    ((-int-) index)
    #{ cvSeqRemove($seq, $index); #}
    ())

#? (cvClearSeq  <seq> )
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvClearSeq
;;  //    Purpose: clears sequence(removes all sequence elements)
;;  //    Context:
;;  //    Parameters:
;;  //         seq - sequence pointer
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void  cvClearSeq( CvSeq* seq );

(de cvClearSeq (seq )
    ((-gptr- "CvSeq *") seq)
    #{ cvClearSeq($seq); #}
    ())

#? (cvGetSeqElem <seq> <index>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGetSeqElem
;;  //    Purpose: finds sequence element by its index
;;  //    Context:
;;  //    Parameters:
;;  //         seq - sequence pointer
;;  //         index - element index
;;  //    Returns:
;;  //         pointer to found element or NULL.
;;  //    Notes:
;;  //         index == -1 means last sequence element, -2 - prelast element etc.
;;  //F*/
;;  OPENCVAPI  char*  cvGetSeqElem( CvSeq* seq, int index, CvSeqBlock** block CV_DEFAULT(0) );

(de cvGetSeqElem(seq index)
    ((-gptr- "CvSeq *") seq)
    ((-int-) index)
    (let ((s (gptr ())))
      #{ $s = (char *) cvGetSeqElem($seq, $index); #}
      s))

#? (cvSeqElemIdx <seq> <element> <block>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSeqElemIdx
;;  //    Purpose: calculates element index from its address
;;  //    Context:
;;  //    Parameters:
;;  //         seq - sequence pointer
;;  //         element - sequence element
;;  //         block - optional output parameter. Sequence block, containing found element.
;;  //    Returns:
;;  //         index of sequence element
;;  //F*/
;;  OPENCVAPI int  cvSeqElemIdx( CvSeq* seq, void* element, CvSeqBlock** block CV_DEFAULT(0) );

(de cvSeqElemIdx(seq element block)
    ((-gptr- "CvSeq *") seq)
    ((-gptr-) element)
    ((-gptr- "CvSeqBlock **") block)
    (let ((s 0))
      ((-int-) s)
      #{ $s = cvSeqElemIdx($seq, $element, $block); #}
      s))

#? (cvStartAppendToSeq  <seq> <writer>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvStartAppendToSeq
;;  //    Purpose: initializes writer state for further writing to sequence
;;  //    Context:
;;  //    Parameters:
;;  //         seq - sequence pointer
;;  //         writer - pointer to initialized writer state
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void  cvStartAppendToSeq( CvSeq* seq, CvSeqWriter* writer );

(de cvStartAppendToSeq (seq writer)
    ((-gptr- "CvSeq *") seq)
    ((-gptr- "CvSeqWriter *") writer)
    #{ cvStartAppendToSeq($seq, $writer); #}
    ())

#? (cvStartWriteSeq <seqflags> <hsize> <esize> <stor> <writer>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvStartWriteSeq
;;  //    Purpose: creates new sequence and initializes writer for it
;;  //    Context:
;;  //    Parameters:
;;  //         seq_flags - flags of created sequence
;;  //         header_size - size of sequence header. Must be non-less than sizeof(CvSeq)
;;  //         elem_size - size of sequence elements
;;  //         storage - memory storage, where the sequence will be located
;;  //         writer - pointer to initialized writer state
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void  cvStartWriteSeq( int seq_flags, int header_size,
;;                                 int elem_size, CvMemStorage* storage,
;;                                 CvSeqWriter* writer );

(de cvStartWriteSeq(seqflags hsize esize stor writer)
    ((-int-) seqflags hsize esize)
    ((-gptr- "CvMemStorage *") stor)
    ((-gptr- "CvSeqWriter *") writer)
    #{ cvStartWriteSeq($seqflags, $hsize, $esize, $stor, $writer); #}
    ())

#? (cvEndWriteSeq  <writer>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvEndWriteSeq
;;  //    Purpose: ends writing process and closes writer
;;  //    Context:
;;  //    Parameters:
;;  //         writer - writer state
;;  //    Returns:
;;  //         written sequence
;;  //F*/
;;  OPENCVAPI  CvSeq*  cvEndWriteSeq( CvSeqWriter* writer );

(de cvEndWriteSeq (writer)
    ((-gptr- "CvSeqWriter *") writer)
    (let ((s (gptr ())))
      #{ $s = (CvSeq *) cvEndWriteSeq($writer); #}
      s))

#? (cvFlushSeqWriter <writer>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvFlushSeqWriter
;;  //    Purpose: updates sequence headers, but don't close writer
;;  //    Context:
;;  //    Parameters:
;;  //         writer - writer state
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void   cvFlushSeqWriter( CvSeqWriter* writer );

(de cvFlushSeqWriter(writer)
    ((-gptr- "CvSeqWriter *") writer)
    #{ cvFlushSeqWriter($writer); #}
    ())

#? (cvStartReadSeq <seq> <reader> <reverse>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvStartReadSeq
;;  //    Purpose: initializes sequence reader
;;  //    Context:
;;  //    Parameters:
;;  //         seq - sequence pointer
;;  //         reader - pointer to initialized reader state
;;  //         reverse - if not 0, function moves read position to the end of sequence
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI void cvStartReadSeq( CvSeq* seq, CvSeqReader* reader, int reverse CV_DEFAULT(0) );

(de cvStartReadSeq(seq reader reverse)
    ((-gptr- "CvSeq *") seq)
    ((-gptr- "CvSeqReader *") reader)
    ((-int-) reverse)
    #{ cvStartReadSeq($seq, $reader, $reverse); #}
    ())

#? (cvGetSeqReaderPos <reader>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGetSeqReaderPos
;;  //    Purpose: returns read position
;;  //    Context:
;;  //    Parameters:
;;  //         reader - reader state
;;  //    Returns:
;;  //         read position
;;  //F*/
;;  OPENCVAPI  int    cvGetSeqReaderPos( CvSeqReader* reader );

(de cvGetSeqReaderPos(reader)
    ((-gptr- "CvSeqReader *") reader)
    (let ((s 0))
      ((-int-) s)
      #{ $s = cvGetSeqReaderPos($reader); #}
      s))

#? (cvSetSeqReaderPos <reader> <index> <isrelative>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSetSeqReaderPos
;;  //    Purpose: moves read position
;;  //    Context:
;;  //    Parameters:
;;  //         index  - new read position
;;  //         is_relative - if not 0, index is offset from current position
;;  //                      (else it is absolute position). Position is changed cyclically
;;  //         reader - reader state
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void   cvSetSeqReaderPos( CvSeqReader* reader, int index,
;;                                    int is_relative CV_DEFAULT(0));

(de cvSetSeqReaderPos(reader index isrelative)
    ((-gptr- "CvSeqReader *") reader)
    ((-int-) index isrelative)
    #{ cvSetSeqReaderPos($reader, $index, $isrelative); #}
    ())

#? (cvCvtSeqToArray <seq> <array> <slice>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCvtSeqToArray
;;  //    Purpose: copies sequence to array
;;  //    Context:
;;  //    Parameters:
;;  //         seq - source sequence
;;  //         array - destination array. Must have capacity at least
;;  //                 seq->total*seq->elem_siz bytes
;;  //    Returns:
;;  //         pointer to array.
;;  //F*/
;;  OPENCVAPI  void*  cvCvtSeqToArray( CvSeq* seq, CvArr* array,
;;                                     CvSlice slice CV_DEFAULT(CV_WHOLE_SEQ) );

(de cvCvtSeqToArray(seq array slice)
    ((-gptr- "CvSeq *") seq)
    ((-gptr- "CvArr *") array)
    ((-gptr- "CvSlice *") slice)
    (let ((s (gptr ())))
      #{ $s = cvCvtSeqToArray($seq, $array, *$slice); #}
      s))

#? (cvMakeSeqHeaderForArray <seqtype> <hsize> <esize> <array> <total> <seq> <block>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvMakeSeqHeaderForArray
;;  //    Purpose: wraps array with sequence(without copying data)
;;  //    Context:
;;  //    Parameters:
;;  //         seq_flags - flags of sequence
;;  //         header_size - size of sequence header. Must be non-less than sizeof(CvSeq)
;;  //         elem_size - size of sequence elements
;;  //         array - source array.
;;  //         total - total number of elements in array
;;  //         seq   - pointer to local structure CvSeq
;;  //         block - pointer to local structure CvSeqBlock
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void  cvMakeSeqHeaderForArray( int seq_type, int header_size,
;;                                            int elem_size, CvArr* array, int total,
;;                                            CvSeq* seq, CvSeqBlock* block );

(de cvMakeSeqHeaderForArray(seqtype hsize esize array total seq block)
    ((-int-) seqtype hsize esize total)
    ((-gptr- "CvArr *") array)
    ((-gptr- "CvSeq *") seq)
    ((-gptr- "CvSeqBlock *") block)
    #{ cvMakeSeqHeaderForArray($seqtype, $hsize, $esize, $array, $total, $seq, $block); #}
    ())

;;  /************ Internal sequence functions ************/
;;  OPENCVAPI  void  cvChangeSeqBlock( CvSeqReader* reader, int direction );
;;  OPENCVAPI  void  cvCreateSeqBlock( CvSeqWriter* writer );

(de cvChangeSeqBlock(reader direction)
    ((-gptr- "CvSeqReader *") reader)
    ((-int-) direction)
    #{ cvChangeSeqBlock($reader, $direction); #}
    ())

(de cvCreateSeqBlock(writer)
    ((-gptr- "CvSeqWriter *") writer)
    #{ cvCreateSeqBlock($writer); #}
    ())




;;******************************************************************************************
;;                      4. functions on CvSet 
;;
;;******************************************************************************************



#? (cvCreateSet <setflags> <hsize> <esize> <stor>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCreateSet
;;  //    Purpose: creates new set
;;  //    Context:
;;  //    Parameters:
;;  //         set_flags - flags of set
;;  //         header_size - size of set header. Must be non-less than sizeof(CvSet)
;;  //         elem_size - size of set elements.
;;  //                     Must be non-less than 8 bytes, divisible by 4.
;;  //                     Least significant bit of first 4-byte field of set elements must
;;  //                     be zero.
;;  //         storage   - memory storage, where the set will be located
;;  //    Returns:
;;  //         created set
;;  //F*/
;;  OPENCVAPI  CvSet*   cvCreateSet( int set_flags, int header_size,
;;                                int elem_size, CvMemStorage* storage );

(de cvCreateSet(setflags hsize esize stor)
    ((-int-) setflags hsize esize)
    ((-gptr- "CvMemStorage *") stor)
    (let ((s (gptr ())))
      #{ $s = (CvSet *) cvCreateSet($setflags, $hsize, $esize, $stor); #}
      s))

#? (cvSetAdd <setstruct> <element> <insertedelement>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSetAdd
;;  //    Purpose: adds new element to the set
;;  //    Context:
;;  //    Parameters:
;;  //         set - set
;;  //         element - optional input parameter. If non NULL, it is copied to inserted
;;  //                   element(starting from second 4-byte field)
;;  //         inserted_element - optional output parameter. If non NULL, address of inserted
;;  //                   element is stored there
;;  //    Returns:
;;  //         index of added element
;;  //F*/
;;  OPENCVAPI  int   cvSetAdd( CvSet* set_struct, CvSetElem* element CV_DEFAULT(0),
;;                             CvSetElem** inserted_element CV_DEFAULT(0) );

(de cvSetAdd(setstruct element insertedelement)
    ((-gptr- "CvSet *") setstruct)
    ((-gptr- "CvSetElem *") element)
    ((-gptr- "CvSetElem **") insertedelement)
    (let ((s 0))
      ((-int-) s)
      #{ $s = cvSetAdd($setstruct, $element, $insertedelement); #}
      s))

#? (cvSetRemove <setstruct> <index>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvSetRemove
;;  //    Purpose: removes element from the set
;;  //    Context:
;;  //    Parameters:
;;  //         set - set
;;  //         index - index of removed element
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void   cvSetRemove( CvSet* set_struct, int index );

(de cvSetRemove(setstruct index)
    ((-gptr- "CvSet *") setstruct)
    ((-int-) index)
    #{ cvSetRemove($setstruct, $index); #}
    ())

#? (cvGetSetElem <setstruct> <index>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGetSetElem
;;  //    Purpose: finds set element by its index
;;  //    Context:
;;  //    Parameters:
;;  //         set - set
;;  //         index - element index
;;  //    Returns:
;;  //         pointer to element or 0 if index is out of range or element at this index
;;  //         isn't in the set
;;  //F*/
;;  OPENCVAPI  CvSetElem*  cvGetSetElem( CvSet* set_struct, int index );

(de cvGetSetElem(setstruct index)
    ((-gptr- "CvSet *") setstruct)
    ((-int-) index)
    (let ((s (gptr ())))
      #{ $s = (CvSetElem *) cvGetSetElem ($setstruct, $index);   #}
      s))

#? (cvClearSet <setstruct>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvClearSet
;;  //    Purpose: clear set(removes all elements from the set)
;;  //    Context:
;;  //    Parameters:
;;  //         set - set
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void   cvClearSet( CvSet* set_struct );

(de cvClearSet(setstruct)
    ((-gptr- "CvSet *") setstruct)
    #{ cvClearSet($setstruct); #}
    ())



;;*****************************************************************************************
;;                        5. functions on CvGraph
;;
;;*****************************************************************************************

;; /*
;;   Graph is represented as a set of vertices.
;;   Vertices contain their adjacency lists (more exactly, pointers to first incoming or
;;   outcoming edge (or 0 if isolated vertex)). Edges are stored in another set.
;;   There is a single-linked list of incoming/outcoming edges for each vertex.
;;   Each edge consists of:
;;     two pointers to the starting and the ending vertices (vtx[0] and vtx[1],
;;     respectively). Graph may be oriented or not. In the second case, edges between
;;     vertex i to vertex j are not distingueshed (during the search operations).
;;     two pointers to next edges for the starting and the ending vertices.
;;     next[0] points to the next edge in the vtx[0] adjacency list and
;;     next[1] points to the next edge in the vtx[1] adjacency list.
;; */


#? (cvCreateGraph <graphflags> <hsize> <vtxsize> <esize> <stor>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvCreateGraph
;;  //    Purpose: creates graph
;;  //    Context:
;;  //    Parameters:
;;  //         graph_flags - flags of created graph. CV_SEQ_KIND_GRAPH must be set,
;;  //                       CV_GRAPH_FLAG_ORIENTED(if set) means oriented graph.
;;  //         header_size - size of graph header. Must be non-less than sizeof(CvGraph)
;;  //         vtx_size - size of graph vertices. Must be GREATER than sizeof(CvGraphVtx).
;;  //                   (for example, sizeof(CvGraphVtx2D) can be used
;;  //                     for simple graphs on the plane)
;;  //         edge_size - size of graph edges. Must be non-less than sizeof(CvGraphEdge)
;;  //         storage   - memory storage, where the graph will be located
;;  //    Returns:
;;  //         created graph
;;  //F*/
;;  OPENCVAPI  CvGraph*   cvCreateGraph( int graph_flags, int header_size,
;;                                    int vtx_size, int edge_size,
;;                                    CvMemStorage* storage );

(de cvCreateGraph(graphflags hsize vtxsize esize stor)
    ((-int-) graphflags hsize vtxsize esize)
    ((-gptr- "CvMemStorage *") stor)
    (let ((s (gptr ())))
      #{ $s = (CvGraph *) cvCreateGraph($graphflags, $hsize, $vtxsize, $esize, $stor); #}
      s))

#? (cvGraphAddVtx <graph> <vertex> <insertedvertex>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGraphAddVtx
;;  //    Purpose: adds vertex to graph
;;  //    Context:
;;  //    Parameters:
;;  //         graph - graph
;;  //         vertex - optional input parameter. If pointer to vertex is not NULL,
;;  //                  it is copied to inserted vertex
;;  //                 (first sizeof(CvGraphVtx) bytes aren't copied)
;;  //         inserted_vertex - optional output parameter. If not NULL, pointer to inserted
;;  //                  vertex is stored there
;;  //    Returns:
;;  //         index of inserted vertex
;;  //F*/
;;  OPENCVAPI  int   cvGraphAddVtx( CvGraph* graph, CvGraphVtx* vertex CV_DEFAULT(0),
;;                                  CvGraphVtx** inserted_vertex CV_DEFAULT(0) );

(de cvGraphAddVtx(graph vertex insertedvertex)
    ((-gptr- "CvGraph *") graph)
    ((-gptr- "CvGraphVtx *") vertex )
    ((-gptr- "CvGraphVtx **") insertedvertex)
    (let ((s 0))
      ((-int-) s)
      #{ $s = cvGraphAddVtx($graph, $vertex, $insertedvertex); #}
      s))
    
#? (cvGraphRemoveVtx <graph> <index>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGraphRemoveVtx, cvGraphRemoveVtxByPtr
;;  //    Purpose: removes vertex from the graph
;;  //    Context:
;;  //    Parameters:
;;  //         graph - graph
;;  //         index - index of removed vertex
;;  //         vtx - pointer to removed vertex
;;  //    Returns:
;;  //    Notes:
;;  //      Vertex is removed with all the incident edges
;;  //F*/
;;  OPENCVAPI  void   cvGraphRemoveVtx( CvGraph* graph, int index );
;;  OPENCVAPI  void   cvGraphRemoveVtxByPtr( CvGraph* graph, CvGraphVtx* vtx );

(de cvGraphRemoveVtx(graph index)
    ((-gptr- "CvGraph *") graph)
    ((-int-) index)
    #{ cvGraphRemoveVtx($graph, $index); #}
    ())

(de cvGraphRemoveVtxByPtr(graph vtx)
    ((-gptr- "CvGraph *") graph)
    ((-gptr- "CvGraphVtx *") vtx)
    #{ cvGraphRemoveVtxByPtr($graph, $vtx); #}
    ())

#? (cvGraphAddEdge <graph> <sidx> <eidx> <edge> <insertededge>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGraphAddEdge, cvGraphAddEdgeByPtr
;;  //    Purpose: add edge to graph
;;  //    Context:
;;  //    Parameters:
;;  //         graph - graph
;;  //         start_idx, end_idx - indices of starting and ending vertices
;;  //         start_vtx, end_vtx - pointers to starting and ending vertices
;;  //         edge - optional input parameter. If not NULL, the edge is copied to
;;  //                inserted edge(first sizeof(CvGraphEdge) bytes aren't copied
;;  //         inserted_edge - optional output parameter. Points to inserted edge.
;;  //    Returns:
;;  //    ... 1 if the edge is inserted, 0 if the vertices were connected already,
;;  //    -1 if a critical error occured (normally, an error message box appears in this case)
;;  //    Notes:
;;  //       starting vertex must differ from ending one.
;;  //F*/
;;  OPENCVAPI  int  cvGraphAddEdge( CvGraph* graph,
;;                                  int start_idx, int end_idx,
;;                                  CvGraphEdge* edge CV_DEFAULT(0),
;;                                  CvGraphEdge** inserted_edge CV_DEFAULT(0) );

(de cvGraphAddEdge(graph sidx eidx edge insertededge)
    ((-gptr- "CvGraph *") graph)
    ((-int-) sidx eidx)
    ((-gptr- "CvGraphEdge *") edge)
    ((-gptr- "CvGraphEdge **") insertededge)
    (let ((s 0))
      ((-int-) s)
      #{ $s = cvGraphAddEdge($graph, $sidx, $eidx, $edge, $insertededge); #}
      s))

;;  OPENCVAPI  int  cvGraphAddEdgeByPtr( CvGraph* graph,
;;                                 CvGraphVtx* start_vtx, CvGraphVtx* end_vtx,
;;                                 CvGraphEdge* edge CV_DEFAULT(0),
;;                                 CvGraphEdge** inserted_edge CV_DEFAULT(0) );

(de cvGraphAddEdgeByPtr(graph svtx evtx edge insertededge)
    ((-gptr- "CvGraph *") graph)
    ((-gptr- "CvGraphVtx *") svtx evtx)
    ((-gptr- "CvGraphEdge *") edge)
    ((-gptr- "CvGraphEdge **") insertededge)
    (let ((s 0))
      ((-int-) s)
      #{ $s = cvGraphAddEdgeByPtr($graph, $svtx, $evtx, $edge, $insertededge); #}
      s))


#? (cvGraphRemoveEdge <graph> <sidx> <eidx>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGraphRemoveEdge, cvGraphRemoveEdgeByPtr
;;  //    Purpose: removes edge to graph
;;  //    Context:
;;  //    Parameters:
;;  //         graph - graph
;;  //         start_idx, end_idx - indices of starting and ending vertices
;;  //         start_vtx, end_vtx - pointers to starting and ending vertices
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void   cvGraphRemoveEdge( CvGraph* graph, int start_idx, int end_idx );

(de cvGraphRemoveEdge(graph sidx eidx)
    ((-gptr- "CvGraph *") graph)
    ((-int-) sidx eidx)
    #{  cvGraphRemoveEdge($graph, $sidx, $eidx); #}
    ())

;;  OPENCVAPI  void   cvGraphRemoveEdgeByPtr( CvGraph* graph, CvGraphVtx* start_vtx,
;;                                            CvGraphVtx* end_vtx );

(de cvGraphRemoveEdgeByPtr(graph svtx evtx)
    ((-gptr- "CvGraph *") graph)
    ((-gptr- "CvGraphVtx *") svtx evtx)
    #{  cvGraphRemoveEdgeByPtr($graph, $svtx, $evtx); #}
    ())


#? (cvFindGraphEdge <graph> <sidx> <eidx>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvFindGraphEdge, cvFindGraphEdgeByPtr
;;  //    Purpose: finds edge, connecting two vertices. If graph is orientation, order
;;  //             of input vertices is taken into account
;;  //    Context:
;;  //    Parameters:
;;  //         graph - graph
;;  //         start_idx, end_idx - indices of starting and ending vertices
;;  //         start_vtx, end_vtx - pointers to starting and ending vertices
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  CvGraphEdge*  cvFindGraphEdge( CvGraph* graph, int start_idx, int end_idx );

(de cvFindGraphEdge(graph sidx eidx)
    ((-gptr- "CvGraph *") graph)
    ((-int-) sidx eidx)
    (let ((s (gptr ())))
      #{ $s = (CvGraphEdge *) cvFindGraphEdge($graph, $sidx, $eidx); #}
      s))

;;  OPENCVAPI  CvGraphEdge*  cvFindGraphEdgeByPtr( CvGraph* graph, CvGraphVtx* start_vtx,
;;                                                 CvGraphVtx* end_vtx );

(de cvFindGraphEdgeByPtr(graph svtx evtx)
    ((-gptr- "CvGraph *") graph)
    ((-gptr- "CvGraphVtx *") svtx evtx)
    (let ((s (gptr ())))
      #{ $s = (CvGraphEdge *) cvFindGraphEdgeByPtr($graph, $svtx, $evtx); #}
      s))


#? (cvClearGraph <graph>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvClearGraph
;;  //    Purpose: clear graph(removes all the edges and vertices from the graph)
;;  //    Context:
;;  //    Parameters:
;;  //         graph - graph
;;  //    Returns:
;;  //F*/
;;  OPENCVAPI  void  cvClearGraph( CvGraph* graph );

(de cvClearGraph(graph)
    ((-gptr- "CvGraph *") graph)
    #{ cvClearGraph($graph); #}
    ())

#? (cvGraphVtxDegree <graph> <vtxidx>)
;;.VP
;;  /*F///////////////////////////////////////////////////////////////////////////////////////
;;  //    Name:    cvGraphVtxDegree, cvGraphVtxDegreeByPtr
;;  //    Purpose: counts edges, incident to given vertex
;;  //    Context:
;;  //    Parameters:
;;  //         graph - graph
;;  //         vtx_idx - vertex index
;;  //         vtx - pointer to vertex
;;  //    Returns:
;;  //      number of incident edges
;;  //F*/
;;  OPENCVAPI  int  cvGraphVtxDegree( CvGraph* graph, int vtx_idx );

(de cvGraphVtxDegree(graph vtxidx)
    ((-gptr- "CvGraph *") graph)
    ((-int-) vtxidx)
    (let ((s 0))
      ((-int-) s)
      #{ $s = cvGraphVtxDegree($graph,$vtxidx); #}
      s))

#? * (cvgraphvtxdegreebyptr <graph> <vtx>)
;;.PRE
;;  OPENCVAPI  int  cvGraphVtxDegreeByPtr( CvGraph* graph, CvGraphVtx* vtx );
(de cvGraphVtxDegreeByPtr(graph vtx)
    ((-gptr- "CvGraph *") graph)
    ((-gptr- "CvGraphVtx *") vtx)
    (let ((s 0))
      ((-int-) s)
      #{ $s = cvGraphVtxDegreeByPtr($graph,$vtx); #}
      s))





;;*************************************************************************************************
;;                      6. small objects
;;
;;*************************************************************************************************

#? * (cvrecttoroi <rect> <coi> <roi>)
;;.PRE
(de cvRectToROI(rect coi roi)
    ((-gptr- "CvRect *") rect)
    ((-int-) coi)
    ((-gptr- "IplROI *") roi)
     #{ {
    IplROI tmp;
    tmp = cvRectToROI(*$rect, $coi);
    memcpy($roi,&tmp,sizeof(IplROI));
    } #}
    ())



#? * (cvroitorect <roi> <rect>)
;;.PRE
(de cvROIToRect (roi rect)
    ((-gptr- "IplROI *") roi)
    ((-gptr- "CvRect *") rect)
    #{ {
    CvRect tmp;
    tmp = cvROIToRect(*$roi);
    memcpy($rect,&tmp,sizeof(CvRect));
    } #}
    ())



;;**************************************************************************************************
;;                7. some fast algorithm
;;
;;**************************************************************************************************


#? * (cvround <val>)
;;.PRE
(de cvRound (val)
    ((-double-) val)
    (int #{ cvRound($val) #} ))


#? * (cvfloor <val>)
;;.PRE
(de cvFloor (val)
    ((-double-) val)
    (int #{ cvFloor($val) #}))


#? * (cvceil <val>)
;;.PRE
(de cvCeil (val)
    ((-double-) val)
    (int #{ cvCeil($val) #}))


#? * (cvinvsqrt <arg>)
;;.PRE
(de cvInvSqrt (arg)
    ((-float-) arg)
    (float #{ cvInvSqrt($arg) #} ))


#? * (cvsqrt <arg>)
;;.PRE
(de cvSqrt (arg)
    ((-float-) arg)
    (float #{ cvSqrt($arg) #} ))




;; ********************************************************

(dhc-make ()
  dummy_data_structures
  cvcreateimageheader
  cvinitimageheader
  cvcreateimage
  cvreleaseimageheader
  cvreleaseimage
  cvcloneimage
  cvsetimagecoi
  cvgetimagecoi
  cvsetimageroi
  cvresetimageroi
  cvgetimageroi
  cvcreatematheader
  cvinitmatheader
  cvcreatemat
  cvreleasematheader
  cvreleasemat
  cvclonemat
  cvgetsubarr
  cvgetrow
  cvgetcol
  cvgetdiag
  ;; added
  cvgetelemtype
  cvgetdims
  cvgetdimsize
  cvptr1d
  cvget1d
  cvgetreal1d
  cvset1d
  cvsetreal1d
  ;;
  cvptr2d
  cvget2d
  cvset2d
  ;; added
  cvgetreal2d
  cvsetreal2d
  ;;
  cvgetmat
  cvgetimage
  cvreshape
  cvcreatedata
  cvreleasedata
  cvsetdata
  cvgetrawdata
  cvgetsize
  cvcopy
  cvset
  cvlut
  cvmget
  cvmset
  cvcreateseq
  cvsetseqblocksize
  cvseqpush
  cvseqpushfront
  cvseqpop
  cvseqpopfront
  cvseqpushmulti
  cvseqpopmulti
  cvseqinsert
  cvseqremove
  cvclearseq
  cvgetseqelem
  cvseqelemidx
  cvstartappendtoseq
  cvstartwriteseq
  cvendwriteseq
  cvflushseqwriter
  cvstartreadseq
  cvgetseqreaderpos
  cvsetseqreaderpos
  cvcvtseqtoarray
  cvmakeseqheaderforarray
  cvchangeseqblock
  cvcreateseqblock
  cvcreateset
  cvsetadd
  cvsetremove
  cvgetsetelem
  cvclearset
  cvcreategraph
  cvgraphaddvtx
  cvgraphremovevtx
  cvgraphremovevtxbyptr
  cvgraphaddedge
  cvgraphaddedgebyptr
  cvgraphremoveedge
  cvgraphremoveedgebyptr
  cvfindgraphedge
  cvfindgraphedgebyptr
  cvcleargraph
  cvgraphvtxdegree
  cvgraphvtxdegreebyptr
  cvrecttoroi
  cvroitorect
  cvround
  cvfloor
  cvceil
  cvinvsqrt
  cvsqrt
)
